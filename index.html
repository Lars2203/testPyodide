<!DOCTYPE html>
<html>
<head>
    <title>Image Processing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <style>
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .controls {
            margin: 20px 0;
        }
        .slider-container {
            margin: 10px 0;
        }
        canvas {
            max-width: 100%;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Image Processing</h1>
        
        <div class="controls">
            <div class="slider-container">
                <label for="threshold">Threshold Value (0-1): </label>
                <input type="range" id="threshold" min="0" max="100" value="50">
                <span id="thresholdValue">0.5</span>
            </div>
            
            <div class="slider-container">
                <label for="kernelSize">Kernel Size (3-11): </label>
                <input type="range" id="kernelSize" min="3" max="11" step="2" value="3">
                <span id="kernelSizeValue">3</span>
            </div>
            
            <div>
                <button onclick="applyDilation()">Apply Dilation</button>
                <button onclick="applyErosion()">Apply Erosion</button>
                <button onclick="resetImage()">Reset Image</button>
            </div>
        </div>

        <canvas id="inputCanvas"></canvas>
        <canvas id="outputCanvas"></canvas>
    </div>

    <script>
        let originalImageTensor;
        let currentImageTensor;
        const inputCanvas = document.getElementById('inputCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const thresholdSlider = document.getElementById('threshold');
        const kernelSizeSlider = document.getElementById('kernelSize');
        const thresholdValue = document.getElementById('thresholdValue');
        const kernelSizeValue = document.getElementById('kernelSizeValue');

        // Load and process the image
        async function loadImage() {
            const img = new Image();
            img.src = 'gray.png';
            await img.decode();
            
            inputCanvas.width = img.width;
            inputCanvas.height = img.height;
            outputCanvas.width = img.width;
            outputCanvas.height = img.height;

            const ctx = inputCanvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            originalImageTensor = tf.tidy(() => {
                return tf.browser.fromPixels(imageData, 1)
                    .toFloat()
                    .div(tf.scalar(255));
            });
            currentImageTensor = originalImageTensor.clone();
            
            applyThreshold();
        }

        // Apply threshold to the image
        function applyThreshold() {
            const threshold = parseInt(thresholdSlider.value) / 100;
            thresholdValue.textContent = threshold.toFixed(2);
            
            tf.tidy(() => {
                const thresholded = currentImageTensor.greater(threshold).toFloat();
                displayTensor(thresholded);
            });
        }

        // Create kernel for morphological operations
        function createKernel(size) {
            return tf.tidy(() => tf.ones([size, size, 1, 1]).toFloat());
        }

        // Apply dilation
        function applyDilation() {
            const kernelSize = parseInt(kernelSizeSlider.value);
            kernelSizeValue.textContent = kernelSize;
            
            tf.tidy(() => {
                const kernel = createKernel(kernelSize);
                const input = currentImageTensor.expandDims(0).expandDims(-1);
                const dilated = tf.conv2d(input, kernel, 1, 'same');
                currentImageTensor = dilated.squeeze();
                displayTensor(currentImageTensor);
            });
        }

        // Apply erosion
        function applyErosion() {
            const kernelSize = parseInt(kernelSizeSlider.value);
            kernelSizeValue.textContent = kernelSize;
            
            tf.tidy(() => {
                const kernel = createKernel(kernelSize);
                const input = currentImageTensor.expandDims(0).expandDims(-1);
                const eroded = tf.conv2d(
                    input,
                    kernel.mul(-1).add(1),
                    1,
                    'same'
                );
                currentImageTensor = eroded.squeeze();
                displayTensor(currentImageTensor);
            });
        }

        // Reset the image to original
        function resetImage() {
            currentImageTensor.dispose();
            currentImageTensor = originalImageTensor.clone();
            applyThreshold();
        }

        // Display tensor on canvas
        async function displayTensor(tensor) {
            // Clone and normalize tensor for display
            const displayTensor = tf.tidy(() => {
                return tensor.clone().clipByValue(0, 1).mul(255);
            });
            
            try {
                await tf.browser.toPixels(displayTensor, outputCanvas);
            } finally {
                displayTensor.dispose();
            }
        }

        // Event listeners
        thresholdSlider.addEventListener('input', applyThreshold);
        kernelSizeSlider.addEventListener('input', () => {
            kernelSizeValue.textContent = kernelSizeSlider.value;
        });

        // Initialize
        loadImage().catch(console.error);

        // Cleanup on page unload
        window.addEventListener('unload', () => {
            if (originalImageTensor) originalImageTensor.dispose();
            if (currentImageTensor) currentImageTensor.dispose();
        });
    </script>
</body>
</html>