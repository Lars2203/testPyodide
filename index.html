<!DOCTYPE html>
<html>
<head> 
    <title>Image Processing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <style>
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .controls {
            margin: 20px 0;
        }
        .slider-container {
            margin: 10px 0;
        }
        canvas {
            max-width: 100%;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Image Processing</h1>
        
        <div class="controls">
            <div class="slider-container">
                <label for="threshold">Threshold Value (0-1): </label>
                <input type="range" id="threshold" min="0" max="100" value="50">
                <span id="thresholdValue">0.5</span>
            </div>
            
            <div class="slider-container">
                <label for="kernelSize">Kernel Size (3-11): </label>
                <input type="range" id="kernelSize" min="3" max="11" step="2" value="3">
                <span id="kernelSizeValue">3</span>
            </div>
            
            <div>
                <button onclick="applyDilation()">Apply Dilation</button>
                <button onclick="applyErosion()">Apply Erosion</button>
                <button onclick="resetImage()">Reset Image</button>
            </div>
        </div>

        <canvas id="inputCanvas" style="display: none;"></canvas>
        <canvas id="outputCanvas"></canvas>
    </div>

    <script>
        let originalImageTensor;
        let currentImageTensor;
        const inputCanvas = document.getElementById('inputCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const thresholdSlider = document.getElementById('threshold');
        const kernelSizeSlider = document.getElementById('kernelSize');
        const thresholdValue = document.getElementById('thresholdValue');
        const kernelSizeValue = document.getElementById('kernelSizeValue');

        async function loadImage() {
            const img = new Image();
            img.src = 'gray.png';
            await img.decode();

            inputCanvas.width = img.width;
            inputCanvas.height = img.height;
            outputCanvas.width = img.width;
            outputCanvas.height = img.height;

            const ctx = inputCanvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            originalImageTensor = tf.tidy(() => {
                return tf.browser.fromPixels(imageData, 1)
                    .toFloat()
                    .div(tf.scalar(255));
            });
            currentImageTensor = originalImageTensor.clone();

            applyThreshold();
        }

        function applyThreshold() {
            const threshold = parseInt(thresholdSlider.value) / 100;
            thresholdValue.textContent = threshold.toFixed(2);

            tf.tidy(() => {
                const thresholded = currentImageTensor.greater(threshold).toFloat();
                displayTensor(thresholded);
            });
        }

        function createDilationKernel(size) {
            return tf.tidy(() => {
                return tf.ones([size, size, 1, 1]);
            });
        }

        function createErosionKernel(size) {
            return tf.tidy(() => {
                return tf.ones([size, size, 1, 1]);
            });
        }

        function applyDilation() {
            const kernelSize = parseInt(kernelSizeSlider.value);
            kernelSizeValue.textContent = kernelSize;

            tf.tidy(() => {
                const kernel = createDilationKernel(kernelSize);
                const input = currentImageTensor.expandDims(2).expandDims(0);
                
                // For dilation, we want the maximum value in the neighborhood
                const dilated = tf.pool(input, [kernelSize, kernelSize], 'max', 'same');
                currentImageTensor = dilated.squeeze([0, 2]);
                displayTensor(currentImageTensor);
            });
        }

        function applyErosion() {
            const kernelSize = parseInt(kernelSizeSlider.value);
            kernelSizeValue.textContent = kernelSize;

            tf.tidy(() => {
                const kernel = createErosionKernel(kernelSize);
                const input = currentImageTensor.expandDims(2).expandDims(0);
                
                // For erosion, we want the minimum value in the neighborhood
                const eroded = tf.pool(input, [kernelSize, kernelSize], 'min', 'same');
                currentImageTensor = eroded.squeeze([0, 2]);
                displayTensor(currentImageTensor);
            });
        }

        function resetImage() {
            currentImageTensor.dispose();
            currentImageTensor = originalImageTensor.clone();
            applyThreshold();
        }

        async function displayTensor(tensor) {
            const displayTensor = tf.tidy(() => {
                return tensor.clone().clipByValue(0, 1);
            });

            try {
                await tf.browser.toPixels(displayTensor, outputCanvas);
            } finally {
                displayTensor.dispose();
            }
        }

        thresholdSlider.addEventListener('input', applyThreshold);
        kernelSizeSlider.addEventListener('input', () => {
            kernelSizeValue.textContent = kernelSizeSlider.value;
        });

        loadImage().catch(console.error);

        window.addEventListener('unload', () => {
            if (originalImageTensor) originalImageTensor.dispose();
            if (currentImageTensor) currentImageTensor.dispose();
        });
    </script>
</body>
</html>